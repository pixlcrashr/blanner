package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pixlcrashr/blanner/src/backend/pkg/optional"
	"github.com/pixlcrashr/blanner/src/backend/pkg/slices"
	"github.com/pixlcrashr/blanner/src/backend/pkg/storage/sql"
	"github.com/pixlcrashr/blanner/src/backend/pkg/transport/graphql/model"
)

// Book is the resolver for the book field.
func (r *accountResolver) Book(ctx context.Context, obj *model.Account) (*model.Book, error) {
	// TODO: replace with data loader

	m, err := r.Storage.Book(
		ctx,
		obj.BookID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromBook(m), nil
}

// Parent is the resolver for the parent field.
func (r *accountResolver) Parent(ctx context.Context, obj *model.Account) (*model.Account, error) {
	if obj.ParentID == nil {
		return nil, nil
	}

	m, err := r.Storage.Account(
		ctx,
		*obj.ParentID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// IsParent is the resolver for the isParent field.
func (r *accountResolver) IsParent(ctx context.Context, obj *model.Account) (bool, error) {
	return obj.ParentID == nil, nil
}

// FullCode is the resolver for the fullCode field.
func (r *accountResolver) FullCode(ctx context.Context, obj *model.Account) (string, error) {
	m, err := r.Storage.AccountFullCodes(ctx, obj.BookID)
	if err != nil {
		return "", err
	}

	codes, ok := m[obj.ID]
	if !ok {
		return "", nil
	}

	return strings.Join(codes, "-"), nil
}

// Depth is the resolver for the depth field.
func (r *accountResolver) Depth(ctx context.Context, obj *model.Account) (int, error) {
	m, err := r.Storage.AccountDepths(
		ctx,
		obj.BookID,
	)
	if err != nil {
		return 0, err
	}

	return m[obj.ID], nil
}

// Children is the resolver for the children field.
func (r *accountResolver) Children(ctx context.Context, obj *model.Account) ([]*model.Account, error) {
	ms, err := r.Storage.SearchAccounts(
		ctx,
		optional.Empty[uuid.UUID](),
		optional.From(obj.ID),
		optional.Empty[bool](),
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccounts(ms), nil
}

// Transactions is the resolver for the transactions field.
func (r *accountResolver) Transactions(ctx context.Context, obj *model.Account) ([]*model.Transaction, error) {
	ms, err := r.Storage.SearchTransactions(
		ctx,
		optional.From(obj.ID),
		optional.Empty[uuid.UUID](),
	)
	if err != nil {
		return nil, err
	}

	return model.FromTransactions(ms), nil
}

// BudgetValues is the resolver for the budgetValues field.
func (r *accountResolver) BudgetValues(ctx context.Context, obj *model.Account) ([]*model.AccountBudgetValue, error) {
	ms, err := r.Storage.AccountBudgetValues(
		ctx,
		obj.ID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccountBudgetValues(ms), nil
}

// Budget is the resolver for the budget field.
func (r *accountBudgetValueResolver) Budget(ctx context.Context, obj *model.AccountBudgetValue) (*model.Budget, error) {
	m, err := r.Storage.Budget(
		ctx,
		obj.BudgetID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// Accounts is the resolver for the accounts field.
func (r *bookResolver) Accounts(ctx context.Context, obj *model.Book) ([]*model.Account, error) {
	ms, err := r.Storage.SearchAccounts(
		ctx,
		optional.From(obj.ID),
		optional.Empty[uuid.UUID](),
		optional.Empty[bool](),
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccounts(ms), nil
}

// Period is the resolver for the period field.
func (r *budgetResolver) Period(ctx context.Context, obj *model.Budget) (*model.Period, error) {
	m, err := r.Storage.Period(
		ctx,
		obj.PeriodID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromPeriod(m), nil
}

// ActualValues is the resolver for the actualValues field.
func (r *budgetResolver) ActualValues(ctx context.Context, obj *model.Budget) ([]*model.BudgetAccountActual, error) {
	ms, err := r.Storage.BudgetActualValues(
		ctx,
		obj.ID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudgetAccountActuals(ms), nil
}

// TargetValues is the resolver for the targetValues field.
func (r *budgetResolver) TargetValues(ctx context.Context, obj *model.Budget) ([]*model.BudgetAccountTarget, error) {
	ms, err := r.Storage.BudgetAccountTargets(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	return model.FromBudgetAccountTargets(ms), nil
}

// Budget is the resolver for the budget field.
func (r *budgetAccountActualResolver) Budget(ctx context.Context, obj *model.BudgetAccountActual) (*model.Budget, error) {
	m, err := r.Storage.Budget(ctx, obj.BudgetID)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// Account is the resolver for the account field.
func (r *budgetAccountActualResolver) Account(ctx context.Context, obj *model.BudgetAccountActual) (*model.Account, error) {
	m, err := r.Storage.Account(ctx, obj.AccountID)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// Budget is the resolver for the budget field.
func (r *budgetAccountTargetResolver) Budget(ctx context.Context, obj *model.BudgetAccountTarget) (*model.Budget, error) {
	m, err := r.Storage.Budget(ctx, obj.BudgetID)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// Account is the resolver for the account field.
func (r *budgetAccountTargetResolver) Account(ctx context.Context, obj *model.BudgetAccountTarget) (*model.Account, error) {
	m, err := r.Storage.Account(ctx, obj.AccountID)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// Account is the resolver for the account field.
func (r *matrixAccountNodeResolver) Account(ctx context.Context, obj *model.MatrixAccountNode) (*model.Account, error) {
	m, err := r.Storage.Account(
		ctx,
		obj.AccountID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// Budget is the resolver for the budget field.
func (r *matrixBudgetNodeResolver) Budget(ctx context.Context, obj *model.MatrixBudgetNode) (*model.Budget, error) {
	m, err := r.Storage.Budget(
		ctx,
		obj.BudgetID,
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// Currency is the resolver for the currency field.
func (r *moneyResolver) Currency(ctx context.Context, obj *model.Money) (string, error) {
	return "EUR", nil
}

// Decimal is the resolver for the decimal field.
func (r *moneyResolver) Decimal(ctx context.Context, obj *model.Money) (float64, error) {
	return float64(obj.MinUnit) / 100.0, nil
}

// Format is the resolver for the format field.
func (r *moneyResolver) Format(ctx context.Context, obj *model.Money) (string, error) {
	return strings.Replace(
		fmt.Sprintf("%.2f â‚¬", float64(obj.MinUnit)/100.0),
		".",
		",",
		-1,
	), nil
}

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, name string, description string, currency string, startMonth int) (*model.Book, error) {
	m, err := r.Storage.CreateBook(
		ctx,
		name,
		description,
		currency,
		int32(startMonth),
	)
	if err != nil {
		return nil, err
	}

	return model.FromBook(m), nil
}

// UpdateBook is the resolver for the updateBook field.
func (r *mutationResolver) UpdateBook(ctx context.Context, id uuid.UUID, name *string, description *string) (*model.Book, error) {
	m, err := r.Storage.UpdateBook(
		ctx,
		id,
		optional.FromNil(name),
		optional.FromNil(description),
	)
	if err != nil {
		return nil, err
	}

	return model.FromBook(m), nil
}

// DeleteBook is the resolver for the deleteBook field.
func (r *mutationResolver) DeleteBook(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.Storage.DeleteBook(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// CreateBudget is the resolver for the createBudget field.
func (r *mutationResolver) CreateBudget(ctx context.Context, bookID uuid.UUID, name string, description string, year int) (*model.Budget, error) {
	m, err := r.Storage.CreateBudget(
		ctx,
		bookID,
		name,
		description,
		int32(year),
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// UpdateBudget is the resolver for the updateBudget field.
func (r *mutationResolver) UpdateBudget(ctx context.Context, id uuid.UUID, name *string, description *string, year *int) (*model.Budget, error) {
	m, err := r.Storage.UpdateBudget(
		ctx,
		id,
		optional.FromNil(name),
		optional.FromNil(description),
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// DeleteBudget is the resolver for the deleteBudget field.
func (r *mutationResolver) DeleteBudget(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.Storage.DeleteBudget(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// SetBudgetAccountTarget is the resolver for the setBudgetAccountTarget field.
func (r *mutationResolver) SetBudgetAccountTarget(ctx context.Context, id uuid.UUID, accountID uuid.UUID, value int64) (bool, error) {
	if err := r.Storage.SetBudgetAccountTarget(ctx, id, accountID, value); err != nil {
		return false, err
	}

	return true, nil
}

// DeleteBudgetAccountTarget is the resolver for the deleteBudgetAccountTarget field.
func (r *mutationResolver) DeleteBudgetAccountTarget(ctx context.Context, id uuid.UUID, accountID uuid.UUID) (bool, error) {
	if err := r.Storage.DeleteBudgetAccountTarget(ctx, id, accountID); err != nil {
		return false, err
	}

	return true, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, bookID uuid.UUID, name string, description string, typeArg model.AccountType, code string, isGroup bool, parentID *uuid.UUID) (*model.Account, error) {
	m, err := r.Storage.CreateAccount(
		ctx,
		bookID,
		name,
		description,
		model.ToAccountType(typeArg),
		code,
		isGroup,
		optional.FromNil(parentID),
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, id uuid.UUID, name *string, description *string) (*model.Account, error) {
	m, err := r.Storage.UpdateAccount(
		ctx,
		id,
		optional.FromNil(name),
		optional.FromNil(description),
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.Storage.DeleteAccount(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// CreateTransaction is the resolver for the createTransaction field.
func (r *mutationResolver) CreateTransaction(ctx context.Context, accountID uuid.UUID, value int64, description string, bookedAt time.Time, importProvider *model.ImportProvider, importReference *string) (*model.Transaction, error) {
	m, err := r.Storage.CreateTransaction(
		ctx,
		accountID,
		value,
		description,
		description,
		bookedAt,
		optional.FromNil(model.FromNilImportProvider(importProvider)),
		optional.FromNil(importReference),
	)
	if err != nil {
		return nil, err
	}

	return model.FromTransaction(m), nil
}

// UpdateTransaction is the resolver for the updateTransaction field.
func (r *mutationResolver) UpdateTransaction(ctx context.Context, id uuid.UUID, accountID *uuid.UUID) (*model.Transaction, error) {
	m, err := r.Storage.UpdateTransaction(
		ctx,
		id,
		optional.FromNil(accountID),
	)
	if err != nil {
		return nil, err
	}

	return model.FromTransaction(m), nil
}

// DeleteTransaction is the resolver for the deleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.Storage.DeleteTransaction(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// ClosePeriod is the resolver for the closePeriod field.
func (r *mutationResolver) ClosePeriod(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.Storage.ClosePeriod(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// IgnoreImportReference is the resolver for the ignoreImportReference field.
func (r *mutationResolver) IgnoreImportReference(ctx context.Context, bookID uuid.UUID, provider model.ImportProvider, reference string) (bool, error) {
	if err := r.Storage.IgnoreImportReference(
		ctx,
		bookID,
		int(model.FromImportProvider(provider)),
		reference,
	); err != nil {
		return false, err
	}

	return true, nil
}

// Currencies is the resolver for the currencies field.
func (r *queryResolver) Currencies(ctx context.Context) ([]string, error) {
	return []string{"EUR"}, nil
}

// SearchBooks is the resolver for the searchBooks field.
func (r *queryResolver) SearchBooks(ctx context.Context) ([]*model.Book, error) {
	ms, err := r.Storage.SearchBooks(ctx)
	if err != nil {
		return nil, err
	}

	return model.FromBooks(ms), nil
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context, ids []uuid.UUID) ([]*model.Book, error) {
	ms, err := r.Storage.Books(ctx, ids)
	if err != nil {
		return nil, err
	}

	return model.FromBooks(ms), nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id uuid.UUID) (*model.Book, error) {
	m, err := r.Storage.Book(ctx, id)
	if err != nil {
		return nil, err
	}

	return model.FromBook(m), nil
}

// SearchPeriods is the resolver for the searchPeriods field.
func (r *queryResolver) SearchPeriods(ctx context.Context, input model.SearchPeriodsInput) ([]*model.Period, error) {
	ms, err := r.Storage.SearchPeriods(
		ctx,
		optional.FromNil(input.BookID),
	)
	if err != nil {
		return nil, err
	}

	return model.FromPeriods(ms), nil
}

// Periods is the resolver for the periods field.
func (r *queryResolver) Periods(ctx context.Context, ids []uuid.UUID) ([]*model.Period, error) {
	ms, err := r.Storage.Periods(ctx, ids)
	if err != nil {
		return nil, err
	}

	return model.FromPeriods(ms), nil
}

// Period is the resolver for the period field.
func (r *queryResolver) Period(ctx context.Context, id uuid.UUID) (*model.Period, error) {
	m, err := r.Storage.Period(ctx, id)
	if err != nil {
		return nil, err
	}

	return model.FromPeriod(m), nil
}

// SearchBudgets is the resolver for the searchBudgets field.
func (r *queryResolver) SearchBudgets(ctx context.Context, input model.SearchBudgetsInput) ([]*model.Budget, error) {
	ms, err := r.Storage.SearchBudgets(
		ctx,
		optional.FromNil(input.PeriodID),
		optional.FromNil(input.BookID),
	)
	if err != nil {
		return nil, err
	}

	return model.FromBudgets(ms), nil
}

// Budgets is the resolver for the budgets field.
func (r *queryResolver) Budgets(ctx context.Context, ids []uuid.UUID) ([]*model.Budget, error) {
	ms, err := r.Storage.Budgets(ctx, ids)
	if err != nil {
		return nil, err
	}

	return model.FromBudgets(ms), nil
}

// Budget is the resolver for the budget field.
func (r *queryResolver) Budget(ctx context.Context, id uuid.UUID) (*model.Budget, error) {
	m, err := r.Storage.Budget(ctx, id)
	if err != nil {
		return nil, err
	}

	return model.FromBudget(m), nil
}

// SearchAccounts is the resolver for the searchAccounts field.
func (r *queryResolver) SearchAccounts(ctx context.Context, input model.SearchAccountsInput) ([]*model.Account, error) {
	ms, err := r.Storage.SearchAccounts(
		ctx,
		optional.FromNil(input.BookID),
		optional.FromNil(input.ParentID),
		optional.FromNil(input.IsGroup),
	)
	if err != nil {
		return nil, err
	}

	return model.FromAccounts(ms), nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, ids []uuid.UUID) ([]*model.Account, error) {
	ms, err := r.Storage.Accounts(ctx, ids)
	if err != nil {
		return nil, err
	}

	return model.FromAccounts(ms), nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id uuid.UUID) (*model.Account, error) {
	m, err := r.Storage.Account(ctx, id)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// SearchTransactions is the resolver for the searchTransactions field.
func (r *queryResolver) SearchTransactions(ctx context.Context, input model.SearchTransactionsInput) ([]*model.Transaction, error) {
	ms, err := r.Storage.SearchTransactions(
		ctx,
		optional.FromNil(input.AccountID),
		optional.FromNil(input.BookID),
	)
	if err != nil {
		return nil, err
	}

	return model.FromTransactions(ms), nil
}

// Transactions is the resolver for the transactions field.
func (r *queryResolver) Transactions(ctx context.Context, ids []uuid.UUID) ([]*model.Transaction, error) {
	ms, err := r.Storage.Transactions(ctx, ids)
	if err != nil {
		return nil, err
	}

	return model.FromTransactions(ms), nil
}

// Transaction is the resolver for the transaction field.
func (r *queryResolver) Transaction(ctx context.Context, id uuid.UUID) (*model.Transaction, error) {
	m, err := r.Storage.Transaction(ctx, id)
	if err != nil {
		return nil, err
	}

	return model.FromTransaction(m), nil
}

// Matrix is the resolver for the matrix field.
func (r *queryResolver) Matrix(ctx context.Context, input model.MatrixInput) (*model.Matrix, error) {
	m, err := r.Storage.Matrix(
		ctx,
		input.BookID,
		optional.FromArray(input.IgnoreBudgets),
	)
	if err != nil {
		return nil, err
	}

	return &model.Matrix{
		Budgets: slices.Map(m.BudgetIDs, func(id uuid.UUID) *model.MatrixBudgetNode {
			return &model.MatrixBudgetNode{BudgetID: id}
		}),
		Accounts: slices.Map(m.AccountNodes, func(node sql.MatrixAccountNode) *model.MatrixAccountNode {
			var parentIndex *int
			if node.ParentIndex.OK() {
				parentIndex = new(int)
				*parentIndex = node.ParentIndex.Value()
			}

			return &model.MatrixAccountNode{
				AccountID:   node.AccountID,
				ParentIndex: parentIndex,
				Depth:       node.Depth,
			}
		}),
		Values: slices.Map(m.Values, func(vs []sql.MatrixValue) []*model.MatrixValue {
			return slices.Map(vs, func(v sql.MatrixValue) *model.MatrixValue {
				return &model.MatrixValue{
					Target:     &model.Money{MinUnit: v.Target},
					Actual:     &model.Money{MinUnit: v.Actual},
					Difference: &model.Money{MinUnit: v.Difference},
				}
			})
		}),
		MaxDepth: m.MaxDepth,
	}, nil
}

// Account is the resolver for the account field.
func (r *transactionResolver) Account(ctx context.Context, obj *model.Transaction) (*model.Account, error) {
	m, err := r.Storage.Account(ctx, obj.AccountID)
	if err != nil {
		return nil, err
	}

	return model.FromAccount(m), nil
}

// IsImported is the resolver for the isImported field.
func (r *transactionResolver) IsImported(ctx context.Context, obj *model.Transaction) (bool, error) {
	return obj.ImportProvider != nil && obj.ImportReference != nil, nil
}

// Account returns AccountResolver implementation.
func (r *Resolver) Account() AccountResolver { return &accountResolver{r} }

// AccountBudgetValue returns AccountBudgetValueResolver implementation.
func (r *Resolver) AccountBudgetValue() AccountBudgetValueResolver {
	return &accountBudgetValueResolver{r}
}

// Book returns BookResolver implementation.
func (r *Resolver) Book() BookResolver { return &bookResolver{r} }

// Budget returns BudgetResolver implementation.
func (r *Resolver) Budget() BudgetResolver { return &budgetResolver{r} }

// BudgetAccountActual returns BudgetAccountActualResolver implementation.
func (r *Resolver) BudgetAccountActual() BudgetAccountActualResolver {
	return &budgetAccountActualResolver{r}
}

// BudgetAccountTarget returns BudgetAccountTargetResolver implementation.
func (r *Resolver) BudgetAccountTarget() BudgetAccountTargetResolver {
	return &budgetAccountTargetResolver{r}
}

// MatrixAccountNode returns MatrixAccountNodeResolver implementation.
func (r *Resolver) MatrixAccountNode() MatrixAccountNodeResolver {
	return &matrixAccountNodeResolver{r}
}

// MatrixBudgetNode returns MatrixBudgetNodeResolver implementation.
func (r *Resolver) MatrixBudgetNode() MatrixBudgetNodeResolver { return &matrixBudgetNodeResolver{r} }

// Money returns MoneyResolver implementation.
func (r *Resolver) Money() MoneyResolver { return &moneyResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

type accountResolver struct{ *Resolver }
type accountBudgetValueResolver struct{ *Resolver }
type bookResolver struct{ *Resolver }
type budgetResolver struct{ *Resolver }
type budgetAccountActualResolver struct{ *Resolver }
type budgetAccountTargetResolver struct{ *Resolver }
type matrixAccountNodeResolver struct{ *Resolver }
type matrixBudgetNodeResolver struct{ *Resolver }
type moneyResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
